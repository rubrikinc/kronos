// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kronos/pb/kronos.proto

package kronospb

import (
	fmt "fmt"

	proto "github.com/gogo/protobuf/proto"

	math "math"

	context "context"

	grpc "google.golang.org/grpc"

	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ServerStatus int32

const (
	// Server is not the oracle and has not synced with the oracle
	// It cannot respond to KronosTime requests
	ServerStatus_NOT_INITIALIZED ServerStatus = 0
	// Server is the oracle or has synced with any oracle
	// It can respond to KronosTime requests if it is the current oracle.
	// KronosTime of initialized servers are valid
	ServerStatus_INITIALIZED ServerStatus = 1
)

var ServerStatus_name = map[int32]string{
	0: "NOT_INITIALIZED",
	1: "INITIALIZED",
}
var ServerStatus_value = map[string]int32{
	"NOT_INITIALIZED": 0,
	"INITIALIZED":     1,
}

func (x ServerStatus) String() string {
	return proto.EnumName(ServerStatus_name, int32(x))
}
func (ServerStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{0}
}

type NodeAddr struct {
	// Host of the node address
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// Port of the node address
	Port                 string   `protobuf:"bytes,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeAddr) Reset()         { *m = NodeAddr{} }
func (m *NodeAddr) String() string { return proto.CompactTextString(m) }
func (*NodeAddr) ProtoMessage()    {}
func (*NodeAddr) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{0}
}
func (m *NodeAddr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeAddr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NodeAddr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAddr.Merge(dst, src)
}
func (m *NodeAddr) XXX_Size() int {
	return m.Size()
}
func (m *NodeAddr) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAddr.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAddr proto.InternalMessageInfo

type OracleState struct {
	// Current id. This is used for CAS operations
	// id is a sequence
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Upper bound to time generated by Kronos
	TimeCap int64 `protobuf:"varint,2,opt,name=time_cap,json=timeCap,proto3" json:"time_cap,omitempty"`
	// Address of current oracle
	Oracle *NodeAddr `protobuf:"bytes,3,opt,name=oracle,proto3" json:"oracle,omitempty"`
	// Upper bound to time generated by Kronos Uptime
	KronosUptimeCap      int64    `protobuf:"varint,4,opt,name=kronos_uptime_cap,json=kronosUptimeCap,proto3" json:"kronos_uptime_cap,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OracleState) Reset()         { *m = OracleState{} }
func (m *OracleState) String() string { return proto.CompactTextString(m) }
func (*OracleState) ProtoMessage()    {}
func (*OracleState) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{1}
}
func (m *OracleState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *OracleState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleState.Merge(dst, src)
}
func (m *OracleState) XXX_Size() int {
	return m.Size()
}
func (m *OracleState) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleState.DiscardUnknown(m)
}

var xxx_messageInfo_OracleState proto.InternalMessageInfo

type OracleProposal struct {
	// Proposal to update the oracle
	ProposedState        *OracleState `protobuf:"bytes,1,opt,name=proposed_state,json=proposedState,proto3" json:"proposed_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *OracleProposal) Reset()         { *m = OracleProposal{} }
func (m *OracleProposal) String() string { return proto.CompactTextString(m) }
func (*OracleProposal) ProtoMessage()    {}
func (*OracleProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{2}
}
func (m *OracleProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *OracleProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleProposal.Merge(dst, src)
}
func (m *OracleProposal) XXX_Size() int {
	return m.Size()
}
func (m *OracleProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleProposal.DiscardUnknown(m)
}

var xxx_messageInfo_OracleProposal proto.InternalMessageInfo

// Node stores the data of a single node that is persisted in cluster info on
// each node.
type Node struct {
	// raft_addr is the address of raft transport of the node.
	RaftAddr *NodeAddr `protobuf:"bytes,1,opt,name=raft_addr,json=raftAddr,proto3" json:"raft_addr,omitempty"`
	// is_removed is true for nodes which have been removed from the kronos raft
	// cluster. Removed node IDs cannot be added back to the cluster.
	IsRemoved            bool     `protobuf:"varint,2,opt,name=is_removed,json=isRemoved,proto3" json:"is_removed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{3}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(dst, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

// Cluster stores the information about cluster that is persisted on each node.
type Cluster struct {
	// all_nodes is a map of NodeId -> Node metadata. This is the same id which is
	// used by raft.
	// This map contains both active nodes and nodes removed from the cluster.
	AllNodes             map[string]*Node `protobuf:"bytes,1,rep,name=all_nodes,json=allNodes,proto3" json:"all_nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{4}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(dst, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

type OracleTimeRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OracleTimeRequest) Reset()         { *m = OracleTimeRequest{} }
func (m *OracleTimeRequest) String() string { return proto.CompactTextString(m) }
func (*OracleTimeRequest) ProtoMessage()    {}
func (*OracleTimeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{5}
}
func (m *OracleTimeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleTimeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *OracleTimeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleTimeRequest.Merge(dst, src)
}
func (m *OracleTimeRequest) XXX_Size() int {
	return m.Size()
}
func (m *OracleTimeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleTimeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OracleTimeRequest proto.InternalMessageInfo

type OracleTimeResponse struct {
	// time is the KronosTime of the oracle.
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	// rtt is the round-trip time for the rpc. this is actually filled on the
	// client side.
	Rtt int64 `protobuf:"varint,2,opt,name=rtt,proto3" json:"rtt,omitempty"`
	// time is the KronosUptime of the oracle.
	Uptime               int64    `protobuf:"varint,3,opt,name=uptime,proto3" json:"uptime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OracleTimeResponse) Reset()         { *m = OracleTimeResponse{} }
func (m *OracleTimeResponse) String() string { return proto.CompactTextString(m) }
func (*OracleTimeResponse) ProtoMessage()    {}
func (*OracleTimeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{6}
}
func (m *OracleTimeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleTimeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *OracleTimeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleTimeResponse.Merge(dst, src)
}
func (m *OracleTimeResponse) XXX_Size() int {
	return m.Size()
}
func (m *OracleTimeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleTimeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OracleTimeResponse proto.InternalMessageInfo

type KronosTimeRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KronosTimeRequest) Reset()         { *m = KronosTimeRequest{} }
func (m *KronosTimeRequest) String() string { return proto.CompactTextString(m) }
func (*KronosTimeRequest) ProtoMessage()    {}
func (*KronosTimeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{7}
}
func (m *KronosTimeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KronosTimeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *KronosTimeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KronosTimeRequest.Merge(dst, src)
}
func (m *KronosTimeRequest) XXX_Size() int {
	return m.Size()
}
func (m *KronosTimeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KronosTimeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KronosTimeRequest proto.InternalMessageInfo

type KronosTimeResponse struct {
	// time is the KronosTime
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	// time_cap is an upper bound to KronosTime. This is periodically updated by
	// the oracle. If the oracle goes down and no new oracle is elected, or if
	// quorum is lost in the cluster, time_cap is used to as a safety measure so
	// that clusters stop serving time. Any time greater than time_cap may not be
	// reliable and not close to actual KronosTime.
	TimeCap int64 `protobuf:"varint,2,opt,name=time_cap,json=timeCap,proto3" json:"time_cap,omitempty"`
	// rtt is the round-trip time for the rpc. this is actually filled on the
	// client side.
	Rtt                  int64    `protobuf:"varint,3,opt,name=rtt,proto3" json:"rtt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KronosTimeResponse) Reset()         { *m = KronosTimeResponse{} }
func (m *KronosTimeResponse) String() string { return proto.CompactTextString(m) }
func (*KronosTimeResponse) ProtoMessage()    {}
func (*KronosTimeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{8}
}
func (m *KronosTimeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KronosTimeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *KronosTimeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KronosTimeResponse.Merge(dst, src)
}
func (m *KronosTimeResponse) XXX_Size() int {
	return m.Size()
}
func (m *KronosTimeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KronosTimeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KronosTimeResponse proto.InternalMessageInfo

type KronosUptimeRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KronosUptimeRequest) Reset()         { *m = KronosUptimeRequest{} }
func (m *KronosUptimeRequest) String() string { return proto.CompactTextString(m) }
func (*KronosUptimeRequest) ProtoMessage()    {}
func (*KronosUptimeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{9}
}
func (m *KronosUptimeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KronosUptimeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *KronosUptimeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KronosUptimeRequest.Merge(dst, src)
}
func (m *KronosUptimeRequest) XXX_Size() int {
	return m.Size()
}
func (m *KronosUptimeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KronosUptimeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KronosUptimeRequest proto.InternalMessageInfo

type KronosUptimeResponse struct {
	// time is the KronosUptime. This is the time for which the Kronos server has
	// been live.
	Uptime int64 `protobuf:"varint,1,opt,name=uptime,proto3" json:"uptime,omitempty"`
	// uptime_cap is an upper bound to KronosUptime. This is periodically updated by
	// the oracle. If the oracle goes down and no new oracle is elected, or if
	// quorum is lost in the cluster, uptime_cap is used to as a safety measure so
	// that clusters stop serving time. Any time greater than uptime_cap may not be
	// reliable and not close to actual KronosUptime.
	UptimeCap int64 `protobuf:"varint,2,opt,name=uptime_cap,json=uptimeCap,proto3" json:"uptime_cap,omitempty"`
	// rtt is the round-trip time for the rpc. this is actually filled on the
	// client side.
	Rtt                  int64    `protobuf:"varint,3,opt,name=rtt,proto3" json:"rtt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KronosUptimeResponse) Reset()         { *m = KronosUptimeResponse{} }
func (m *KronosUptimeResponse) String() string { return proto.CompactTextString(m) }
func (*KronosUptimeResponse) ProtoMessage()    {}
func (*KronosUptimeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{10}
}
func (m *KronosUptimeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KronosUptimeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *KronosUptimeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KronosUptimeResponse.Merge(dst, src)
}
func (m *KronosUptimeResponse) XXX_Size() int {
	return m.Size()
}
func (m *KronosUptimeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KronosUptimeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KronosUptimeResponse proto.InternalMessageInfo

type StatusRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatusRequest) Reset()         { *m = StatusRequest{} }
func (m *StatusRequest) String() string { return proto.CompactTextString(m) }
func (*StatusRequest) ProtoMessage()    {}
func (*StatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{11}
}
func (m *StatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusRequest.Merge(dst, src)
}
func (m *StatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *StatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatusRequest proto.InternalMessageInfo

type StatusResponse struct {
	ServerStatus         ServerStatus `protobuf:"varint,1,opt,name=server_status,json=serverStatus,proto3,enum=kronospb.ServerStatus" json:"server_status,omitempty"`
	OracleState          *OracleState `protobuf:"bytes,2,opt,name=oracle_state,json=oracleState,proto3" json:"oracle_state,omitempty"`
	Delta                int64        `protobuf:"varint,3,opt,name=delta,proto3" json:"delta,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *StatusResponse) Reset()         { *m = StatusResponse{} }
func (m *StatusResponse) String() string { return proto.CompactTextString(m) }
func (*StatusResponse) ProtoMessage()    {}
func (*StatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_kronos_0b5fba119687f72c, []int{12}
}
func (m *StatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusResponse.Merge(dst, src)
}
func (m *StatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatusResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*NodeAddr)(nil), "kronospb.NodeAddr")
	proto.RegisterType((*OracleState)(nil), "kronospb.OracleState")
	proto.RegisterType((*OracleProposal)(nil), "kronospb.OracleProposal")
	proto.RegisterType((*Node)(nil), "kronospb.Node")
	proto.RegisterType((*Cluster)(nil), "kronospb.Cluster")
	proto.RegisterMapType((map[string]*Node)(nil), "kronospb.Cluster.AllNodesEntry")
	proto.RegisterType((*OracleTimeRequest)(nil), "kronospb.OracleTimeRequest")
	proto.RegisterType((*OracleTimeResponse)(nil), "kronospb.OracleTimeResponse")
	proto.RegisterType((*KronosTimeRequest)(nil), "kronospb.KronosTimeRequest")
	proto.RegisterType((*KronosTimeResponse)(nil), "kronospb.KronosTimeResponse")
	proto.RegisterType((*KronosUptimeRequest)(nil), "kronospb.KronosUptimeRequest")
	proto.RegisterType((*KronosUptimeResponse)(nil), "kronospb.KronosUptimeResponse")
	proto.RegisterType((*StatusRequest)(nil), "kronospb.StatusRequest")
	proto.RegisterType((*StatusResponse)(nil), "kronospb.StatusResponse")
	proto.RegisterEnum("kronospb.ServerStatus", ServerStatus_name, ServerStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TimeServiceClient is the client API for TimeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TimeServiceClient interface {
	// OracleTime returns the server's KronosTime if the server believes it is
	// the oracle, otherwise it returns an error.
	// A distributed state machine is used to store the identity of the oracle
	// and it is used by the server to know if it should respond to OracleTime
	// requests.
	// This RPC is used internally by kronos nodes to sync time with the elected
	// oracle.
	// This returns an error if
	// 1. The server is not the current oracle.
	// 2. The server is not initialized.
	// 3. The server's KronosTime is stale (KronosTime > Time Cap). This can
	//    mean that the cluster has lost a quorum of the nodes.
	OracleTime(ctx context.Context, in *OracleTimeRequest, opts ...grpc.CallOption) (*OracleTimeResponse, error)
	// KronosTime returns the server's KronosTime. An application can call this
	// RPC on the local kronos server to get access to KronosTime.
	// This does not validate whether the server is the oracle.
	// This returns an error if the server is not initialized or has
	// a stale KronosTime (KronosTime > Time Cap).
	KronosTime(ctx context.Context, in *KronosTimeRequest, opts ...grpc.CallOption) (*KronosTimeResponse, error)
	// KronosTime returns the server's KronosUptime. An application can call this
	// RPC on the local kronos server to get access to KronosUptime.
	// This does not validate whether the server is the oracle.
	// This returns an error if the server is not initialized or has
	// a stale KronosUptime (KronosUptime > Kronos Uptime Time Cap).
	KronosUptime(ctx context.Context, in *KronosUptimeRequest, opts ...grpc.CallOption) (*KronosUptimeResponse, error)
	// Status returns the status of the server.
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
}

type timeServiceClient struct {
	cc *grpc.ClientConn
}

func NewTimeServiceClient(cc *grpc.ClientConn) TimeServiceClient {
	return &timeServiceClient{cc}
}

func (c *timeServiceClient) OracleTime(ctx context.Context, in *OracleTimeRequest, opts ...grpc.CallOption) (*OracleTimeResponse, error) {
	out := new(OracleTimeResponse)
	err := c.cc.Invoke(ctx, "/kronospb.TimeService/OracleTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeServiceClient) KronosTime(ctx context.Context, in *KronosTimeRequest, opts ...grpc.CallOption) (*KronosTimeResponse, error) {
	out := new(KronosTimeResponse)
	err := c.cc.Invoke(ctx, "/kronospb.TimeService/KronosTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeServiceClient) KronosUptime(ctx context.Context, in *KronosUptimeRequest, opts ...grpc.CallOption) (*KronosUptimeResponse, error) {
	out := new(KronosUptimeResponse)
	err := c.cc.Invoke(ctx, "/kronospb.TimeService/KronosUptime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeServiceClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/kronospb.TimeService/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TimeServiceServer is the server API for TimeService service.
type TimeServiceServer interface {
	// OracleTime returns the server's KronosTime if the server believes it is
	// the oracle, otherwise it returns an error.
	// A distributed state machine is used to store the identity of the oracle
	// and it is used by the server to know if it should respond to OracleTime
	// requests.
	// This RPC is used internally by kronos nodes to sync time with the elected
	// oracle.
	// This returns an error if
	// 1. The server is not the current oracle.
	// 2. The server is not initialized.
	// 3. The server's KronosTime is stale (KronosTime > Time Cap). This can
	//    mean that the cluster has lost a quorum of the nodes.
	OracleTime(context.Context, *OracleTimeRequest) (*OracleTimeResponse, error)
	// KronosTime returns the server's KronosTime. An application can call this
	// RPC on the local kronos server to get access to KronosTime.
	// This does not validate whether the server is the oracle.
	// This returns an error if the server is not initialized or has
	// a stale KronosTime (KronosTime > Time Cap).
	KronosTime(context.Context, *KronosTimeRequest) (*KronosTimeResponse, error)
	// KronosTime returns the server's KronosUptime. An application can call this
	// RPC on the local kronos server to get access to KronosUptime.
	// This does not validate whether the server is the oracle.
	// This returns an error if the server is not initialized or has
	// a stale KronosUptime (KronosUptime > Kronos Uptime Time Cap).
	KronosUptime(context.Context, *KronosUptimeRequest) (*KronosUptimeResponse, error)
	// Status returns the status of the server.
	Status(context.Context, *StatusRequest) (*StatusResponse, error)
}

func RegisterTimeServiceServer(s *grpc.Server, srv TimeServiceServer) {
	s.RegisterService(&_TimeService_serviceDesc, srv)
}

func _TimeService_OracleTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OracleTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeServiceServer).OracleTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kronospb.TimeService/OracleTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeServiceServer).OracleTime(ctx, req.(*OracleTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeService_KronosTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KronosTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeServiceServer).KronosTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kronospb.TimeService/KronosTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeServiceServer).KronosTime(ctx, req.(*KronosTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeService_KronosUptime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KronosUptimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeServiceServer).KronosUptime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kronospb.TimeService/KronosUptime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeServiceServer).KronosUptime(ctx, req.(*KronosUptimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeService_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeServiceServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kronospb.TimeService/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeServiceServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TimeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kronospb.TimeService",
	HandlerType: (*TimeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OracleTime",
			Handler:    _TimeService_OracleTime_Handler,
		},
		{
			MethodName: "KronosTime",
			Handler:    _TimeService_KronosTime_Handler,
		},
		{
			MethodName: "KronosUptime",
			Handler:    _TimeService_KronosUptime_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _TimeService_Status_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kronos/pb/kronos.proto",
}

func (m *NodeAddr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeAddr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKronos(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKronos(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	return i, nil
}

func (m *OracleState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Id))
	}
	if m.TimeCap != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.TimeCap))
	}
	if m.Oracle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Oracle.Size()))
		n1, err := m.Oracle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.KronosUptimeCap != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.KronosUptimeCap))
	}
	return i, nil
}

func (m *OracleProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleProposal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProposedState != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.ProposedState.Size()))
		n2, err := m.ProposedState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftAddr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.RaftAddr.Size()))
		n3, err := m.RaftAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.IsRemoved {
		dAtA[i] = 0x10
		i++
		if m.IsRemoved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllNodes) > 0 {
		keysForAllNodes := make([]string, 0, len(m.AllNodes))
		for k, _ := range m.AllNodes {
			keysForAllNodes = append(keysForAllNodes, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAllNodes)
		for _, k := range keysForAllNodes {
			dAtA[i] = 0xa
			i++
			v := m.AllNodes[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovKronos(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovKronos(uint64(len(k))) + msgSize
			i = encodeVarintKronos(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKronos(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintKronos(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	return i, nil
}

func (m *OracleTimeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleTimeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *OracleTimeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleTimeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Time))
	}
	if m.Rtt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Rtt))
	}
	if m.Uptime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Uptime))
	}
	return i, nil
}

func (m *KronosTimeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KronosTimeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *KronosTimeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KronosTimeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Time))
	}
	if m.TimeCap != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.TimeCap))
	}
	if m.Rtt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Rtt))
	}
	return i, nil
}

func (m *KronosUptimeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KronosUptimeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *KronosUptimeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KronosUptimeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uptime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Uptime))
	}
	if m.UptimeCap != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.UptimeCap))
	}
	if m.Rtt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Rtt))
	}
	return i, nil
}

func (m *StatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.ServerStatus))
	}
	if m.OracleState != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.OracleState.Size()))
		n5, err := m.OracleState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Delta != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Delta))
	}
	return i, nil
}

func encodeVarintKronos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NodeAddr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovKronos(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovKronos(uint64(l))
	}
	return n
}

func (m *OracleState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovKronos(uint64(m.Id))
	}
	if m.TimeCap != 0 {
		n += 1 + sovKronos(uint64(m.TimeCap))
	}
	if m.Oracle != nil {
		l = m.Oracle.Size()
		n += 1 + l + sovKronos(uint64(l))
	}
	if m.KronosUptimeCap != 0 {
		n += 1 + sovKronos(uint64(m.KronosUptimeCap))
	}
	return n
}

func (m *OracleProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposedState != nil {
		l = m.ProposedState.Size()
		n += 1 + l + sovKronos(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RaftAddr != nil {
		l = m.RaftAddr.Size()
		n += 1 + l + sovKronos(uint64(l))
	}
	if m.IsRemoved {
		n += 2
	}
	return n
}

func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllNodes) > 0 {
		for k, v := range m.AllNodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovKronos(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovKronos(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovKronos(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *OracleTimeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *OracleTimeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovKronos(uint64(m.Time))
	}
	if m.Rtt != 0 {
		n += 1 + sovKronos(uint64(m.Rtt))
	}
	if m.Uptime != 0 {
		n += 1 + sovKronos(uint64(m.Uptime))
	}
	return n
}

func (m *KronosTimeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *KronosTimeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovKronos(uint64(m.Time))
	}
	if m.TimeCap != 0 {
		n += 1 + sovKronos(uint64(m.TimeCap))
	}
	if m.Rtt != 0 {
		n += 1 + sovKronos(uint64(m.Rtt))
	}
	return n
}

func (m *KronosUptimeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *KronosUptimeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uptime != 0 {
		n += 1 + sovKronos(uint64(m.Uptime))
	}
	if m.UptimeCap != 0 {
		n += 1 + sovKronos(uint64(m.UptimeCap))
	}
	if m.Rtt != 0 {
		n += 1 + sovKronos(uint64(m.Rtt))
	}
	return n
}

func (m *StatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *StatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerStatus != 0 {
		n += 1 + sovKronos(uint64(m.ServerStatus))
	}
	if m.OracleState != nil {
		l = m.OracleState.Size()
		n += 1 + l + sovKronos(uint64(l))
	}
	if m.Delta != 0 {
		n += 1 + sovKronos(uint64(m.Delta))
	}
	return n
}

func sovKronos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozKronos(x uint64) (n int) {
	return sovKronos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NodeAddr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAddr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAddr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCap", wireType)
			}
			m.TimeCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oracle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Oracle == nil {
				m.Oracle = &NodeAddr{}
			}
			if err := m.Oracle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KronosUptimeCap", wireType)
			}
			m.KronosUptimeCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KronosUptimeCap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProposedState == nil {
				m.ProposedState = &OracleState{}
			}
			if err := m.ProposedState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RaftAddr == nil {
				m.RaftAddr = &NodeAddr{}
			}
			if err := m.RaftAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRemoved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRemoved = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllNodes == nil {
				m.AllNodes = make(map[string]*Node)
			}
			var mapkey string
			var mapvalue *Node
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKronos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKronos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKronos
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKronos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthKronos
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthKronos
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Node{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKronos(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKronos
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AllNodes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleTimeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleTimeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleTimeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleTimeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleTimeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleTimeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			m.Rtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KronosTimeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KronosTimeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KronosTimeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KronosTimeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KronosTimeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KronosTimeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCap", wireType)
			}
			m.TimeCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			m.Rtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KronosUptimeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KronosUptimeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KronosUptimeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KronosUptimeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KronosUptimeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KronosUptimeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UptimeCap", wireType)
			}
			m.UptimeCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UptimeCap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			m.Rtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerStatus", wireType)
			}
			m.ServerStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerStatus |= (ServerStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OracleState == nil {
				m.OracleState = &OracleState{}
			}
			if err := m.OracleState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			m.Delta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delta |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKronos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthKronos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowKronos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipKronos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthKronos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKronos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("kronos/pb/kronos.proto", fileDescriptor_kronos_0b5fba119687f72c) }

var fileDescriptor_kronos_0b5fba119687f72c = []byte{
	// 671 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xcb, 0x4e, 0xdb, 0x40,
	0x14, 0xcd, 0xc4, 0x21, 0x24, 0xd7, 0x79, 0xc0, 0xf0, 0x68, 0x9a, 0x16, 0x17, 0x59, 0x5d, 0x20,
	0x16, 0x41, 0x72, 0xbb, 0x40, 0x2d, 0x5d, 0x50, 0xca, 0x22, 0xa2, 0x0a, 0x95, 0x81, 0x2e, 0xd8,
	0x58, 0x06, 0x4f, 0x55, 0x0b, 0x93, 0x71, 0x67, 0x6c, 0x24, 0xfe, 0x82, 0x45, 0xb7, 0xfd, 0x8a,
	0xfe, 0x04, 0xcb, 0x2e, 0xbb, 0x6c, 0xd3, 0x1f, 0xa9, 0xe6, 0xe1, 0x64, 0xc2, 0x23, 0xbb, 0xfb,
	0x98, 0x7b, 0xcf, 0xf1, 0x9c, 0xe3, 0x81, 0xd5, 0x0b, 0x46, 0x87, 0x94, 0x6f, 0xa5, 0x67, 0x5b,
	0x2a, 0xea, 0xa5, 0x8c, 0x66, 0x14, 0xd7, 0x54, 0x96, 0x9e, 0xb9, 0x1e, 0xd4, 0x06, 0x34, 0x22,
	0xbb, 0x51, 0xc4, 0x30, 0x86, 0xca, 0x57, 0xca, 0xb3, 0x0e, 0x5a, 0x47, 0x1b, 0x75, 0x5f, 0xc6,
	0xa2, 0x96, 0x52, 0x96, 0x75, 0xca, 0xaa, 0x26, 0x62, 0xf7, 0x06, 0x81, 0x7d, 0xc8, 0xc2, 0xf3,
	0x84, 0x1c, 0x65, 0x61, 0x46, 0x70, 0x0b, 0xca, 0x71, 0x24, 0xa7, 0x2a, 0x7e, 0x39, 0x8e, 0xf0,
	0x53, 0xa8, 0x65, 0xf1, 0x25, 0x09, 0xce, 0xc3, 0x54, 0xce, 0x59, 0xfe, 0xbc, 0xc8, 0xf7, 0xc2,
	0x14, 0x6f, 0x42, 0x95, 0xca, 0xc9, 0x8e, 0xb5, 0x8e, 0x36, 0x6c, 0x0f, 0xf7, 0x0a, 0x26, 0xbd,
	0x82, 0x86, 0xaf, 0x4f, 0xe0, 0x4d, 0x58, 0x54, 0xcd, 0x20, 0x4f, 0xc7, 0xfb, 0x2a, 0x72, 0x5f,
	0x5b, 0x35, 0x4e, 0x52, 0xbd, 0xd7, 0x1d, 0x40, 0x4b, 0x31, 0xfa, 0xc4, 0x68, 0x4a, 0x79, 0x98,
	0xe0, 0x1d, 0x68, 0xa5, 0x32, 0x26, 0x51, 0xc0, 0x05, 0x4d, 0x49, 0xd0, 0xf6, 0x56, 0x26, 0x88,
	0xc6, 0x37, 0xf8, 0xcd, 0xe2, 0xb0, 0x4c, 0xdd, 0xcf, 0x50, 0x11, 0x7c, 0xf0, 0x16, 0xd4, 0x59,
	0xf8, 0x25, 0x0b, 0xc2, 0x28, 0x62, 0x7a, 0xc1, 0x43, 0x94, 0x6b, 0xe2, 0x90, 0xbc, 0xc3, 0x35,
	0x80, 0x98, 0x07, 0x8c, 0x5c, 0xd2, 0x2b, 0x12, 0xc9, 0xaf, 0xaf, 0xf9, 0xf5, 0x98, 0xfb, 0xaa,
	0xe0, 0x7e, 0x47, 0x30, 0xbf, 0x97, 0xe4, 0x3c, 0x23, 0x0c, 0xef, 0x40, 0x3d, 0x4c, 0x92, 0x60,
	0x48, 0x23, 0xc2, 0x3b, 0x68, 0xdd, 0xda, 0xb0, 0xbd, 0x17, 0x93, 0xdd, 0xfa, 0x54, 0x6f, 0x37,
	0x49, 0x04, 0x0c, 0xdf, 0x1f, 0x66, 0xec, 0xda, 0xaf, 0x85, 0x3a, 0xed, 0x1e, 0x40, 0x73, 0xaa,
	0x85, 0x17, 0xc0, 0xba, 0x20, 0xd7, 0x5a, 0x3c, 0x11, 0xe2, 0x97, 0x30, 0x77, 0x15, 0x26, 0x39,
	0x91, 0x34, 0x6c, 0xaf, 0x35, 0x4d, 0xdc, 0x57, 0xcd, 0x37, 0xe5, 0x6d, 0xe4, 0x2e, 0xc1, 0xa2,
	0xba, 0x8c, 0xe3, 0xf8, 0x92, 0xf8, 0xe4, 0x5b, 0x4e, 0x78, 0xe6, 0xfa, 0x80, 0xcd, 0x22, 0x4f,
	0xe9, 0x90, 0x13, 0x61, 0x08, 0x71, 0xe9, 0x12, 0xc7, 0xf2, 0x65, 0x2c, 0xa0, 0x59, 0x96, 0x69,
	0xad, 0x45, 0x88, 0x57, 0xa1, 0xaa, 0x44, 0x93, 0x3a, 0x5b, 0xbe, 0xce, 0x04, 0xd0, 0x81, 0x24,
	0x61, 0x02, 0x9d, 0x00, 0x36, 0x8b, 0x33, 0x80, 0x66, 0x38, 0x4b, 0x73, 0xb0, 0xc6, 0x1c, 0xdc,
	0x15, 0x58, 0x3a, 0x30, 0x6c, 0x52, 0xa0, 0x05, 0xb0, 0x3c, 0x5d, 0xd6, 0x78, 0x13, 0xca, 0xc8,
	0xa4, 0x2c, 0x14, 0x35, 0xfc, 0xa7, 0x50, 0xeb, 0x79, 0xfa, 0x38, 0x6e, 0x1b, 0x9a, 0xc2, 0x44,
	0x39, 0x2f, 0x10, 0x7f, 0x20, 0x68, 0x15, 0x15, 0x0d, 0xf6, 0x16, 0x9a, 0x9c, 0xb0, 0x2b, 0xc2,
	0xa4, 0x37, 0x73, 0x2e, 0x31, 0x5b, 0xde, 0xea, 0x44, 0xa2, 0x23, 0xd9, 0xd6, 0x63, 0x0d, 0x6e,
	0x64, 0x78, 0x1b, 0x1a, 0xea, 0x17, 0xd1, 0xc6, 0x2e, 0xcf, 0x32, 0xb6, 0x4d, 0x8d, 0x3f, 0x75,
	0x19, 0xe6, 0x22, 0x92, 0x64, 0xa1, 0xa6, 0xab, 0x92, 0xcd, 0xd7, 0xd0, 0x30, 0xd1, 0xf0, 0x12,
	0xb4, 0x07, 0x87, 0xc7, 0x41, 0x7f, 0xd0, 0x3f, 0xee, 0xef, 0x7e, 0xec, 0x9f, 0xee, 0x7f, 0x58,
	0x28, 0xe1, 0x36, 0xd8, 0x66, 0x01, 0x79, 0x3f, 0xcb, 0x60, 0x0b, 0xc1, 0xc4, 0x68, 0x7c, 0x4e,
	0x70, 0x1f, 0x60, 0x62, 0x17, 0xfc, 0xec, 0x2e, 0x1b, 0x43, 0xf0, 0xee, 0xf3, 0x87, 0x9b, 0xea,
	0x6e, 0xdc, 0x92, 0x58, 0x35, 0x31, 0x84, 0xb9, 0xea, 0x9e, 0x77, 0xcc, 0x55, 0xf7, 0x3d, 0xe4,
	0x96, 0xf0, 0x21, 0x34, 0x4c, 0xb5, 0xf1, 0xda, 0xdd, 0xf3, 0x53, 0xe6, 0xe8, 0x3a, 0x8f, 0xb5,
	0xc7, 0x0b, 0xdf, 0x41, 0x55, 0x5f, 0xd3, 0x13, 0x43, 0x2c, 0x53, 0xef, 0x6e, 0xe7, 0x7e, 0xa3,
	0x18, 0x7f, 0xef, 0xde, 0xfe, 0x75, 0x4a, 0xb7, 0x23, 0x07, 0xfd, 0x1a, 0x39, 0xe8, 0xf7, 0xc8,
	0x41, 0x7f, 0x46, 0x0e, 0xba, 0xf9, 0xe7, 0x94, 0x4e, 0xc7, 0x6f, 0xf2, 0x59, 0x55, 0x3e, 0xd2,
	0xaf, 0xfe, 0x07, 0x00, 0x00, 0xff, 0xff, 0x7b, 0x5b, 0x06, 0x7b, 0xbe, 0x05, 0x00, 0x00,
}
