syntax = "proto3";

package kronospb;
option go_package = "kronospb";

message NodeAddr {
  // Host of the node address
  string host = 1;
  // Port of the node address
  string port = 2;
}

message OracleState {
  // Current id. This is used for CAS operations
  // id is a sequence
  uint64 id = 1;
  // Upper bound to time generated by Kronos
  int64 time_cap = 2;
  // Address of current oracle
  NodeAddr oracle = 3;
}

message OracleProposal {
  // Proposal to update the oracle
  OracleState proposed_state = 1;
}

// Node stores the data of a single node that is persisted in cluster info on
// each node.
message Node {
  // raft_addr is the address of raft transport of the node.
  NodeAddr raft_addr = 1;
  // is_removed is true for nodes which have been removed from the kronos raft
  // cluster. Removed node IDs cannot be added back to the cluster.
  bool is_removed = 2;
}

// Cluster stores the information about cluster that is persisted on each node.
message Cluster {
  // all_nodes is a map of NodeId -> Node metadata. This is the same id which is
  // used by raft.
  // This map contains both active nodes and nodes removed from the cluster.
  map<string, Node> all_nodes = 1;
}

enum ServerStatus {
  // Server is not the oracle and has not synced with the oracle
  // It cannot respond to KronosTime requests
  NOT_INITIALIZED = 0;
  // Server is the oracle or has synced with any oracle
  // It can respond to KronosTime requests if it is the current oracle.
  // KronosTime of initialized servers are valid
  INITIALIZED = 1;
}

message OracleTimeRequest {
}

message OracleTimeResponse {
  // time is the KronosTime of the oracle.
  int64 time = 1;
  // rtt is the round-trip time for the rpc. this is actually filled on the
  // client side.
  int64 rtt = 2;
}

message KronosTimeRequest {
}

message KronosTimeResponse {
  // time is the KronosTime
  int64 time = 1;
  // time_cap is an upper bound to KronosTime. This is periodically updated by
  // the oracle. If the oracle goes down and no new oracle is elected, or if
  // quorum is lost in the cluster, time_cap is used to as a safety measure so
  // that clusters stop serving time. Any time greater than time_cap may not be
  // reliable and not close to actual KronosTime.
  int64 time_cap = 2;
  // rtt is the round-trip time for the rpc. this is actually filled on the
  // client side.
  int64 rtt = 3;
}

message StatusRequest {
}

message StatusResponse {
  ServerStatus server_status = 1;
  OracleState oracle_state = 2;
  int64 delta = 3;
}

service TimeService {
    // OracleTime returns the server's KronosTime if the server believes it is
    // the oracle, otherwise it returns an error.
    // A distributed state machine is used to store the identity of the oracle
    // and it is used by the server to know if it should respond to OracleTime
    // requests.
    // This RPC is used internally by kronos nodes to sync time with the elected
    // oracle.
    // This returns an error if
    // 1. The server is not the current oracle.
    // 2. The server is not initialized.
    // 3. The server's KronosTime is stale (KronosTime > Time Cap). This can
    //    mean that the cluster has lost a quorum of the nodes.
    rpc OracleTime (OracleTimeRequest) returns (OracleTimeResponse) {}
    // KronosTime returns the server's KronosTime. An application can call this
    // RPC on the local kronos server to get access to KronosTime.
    // This does not validate whether the server is the oracle.
    // This returns an error if the server is not initialized or has
    // a stale KronosTime (KronosTime > Time Cap).
    rpc KronosTime (KronosTimeRequest) returns (KronosTimeResponse) {}
    // Status returns the status of the server.
    rpc Status (StatusRequest) returns (StatusResponse) {}
}
